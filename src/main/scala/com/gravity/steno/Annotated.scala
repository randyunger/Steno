/**
 * Copyright 2009 The Apache Software Foundation
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gravity.steno

import scalaz._, Scalaz._

/**
 * Created by runger on 3/14/14.
 */

object grvannotation extends grvannotation {

  object BasicNoteTypes {

    /**
     * A helper when defining a new stage.
     * Your makeNote method can be like so: new MsgNote(message) with StageNote
     */
    case class MsgNote(message: String) extends BasicMessageNote //The existence of an implementation here pushes us towards an inheritance model instead of a path-dependent type model.

    /**
     * A container for your StageMeta type. You will also want to define a case class for MetaType with Optional values for whatever meta data you want to stash.
     * case class StageMeta(name: Option[String] = None, context: Option[(URL, Timestamp)])
     * @param message The text that accompanies your Meta data when rendering via [[com.gravity.steno.grvstage.Pipeline]]
     * @param meta an instance of the Stage's MetaType
     * @param canContinue a boolean indicating whether this is a critical value whose bad state cannot be recovered from
     * @tparam MetaType the type of meta. (MetaType <: Product) means that MetaType is a case class.
     */
    class SimpleMessageMetaNote[MetaType <: Product](val message: String, val meta: MetaType, val canContinue: Boolean) extends BasicMessageMetaNote[MetaType]

    /**
     * Annotated enforces that all Notes must extend this trait
     */
    trait Note


    trait BasicMessageNote extends Note {
      def message: String
    }

    trait BasicMetaNote[MetaType <: Product] extends Note {
      def meta: MetaType
      def canContinue: Boolean
    }

    trait BasicMessageMetaNote[T <: Product] extends BasicMetaNote[T] with BasicMessageNote

  }
}

trait grvannotation {
  import grvannotation.BasicNoteTypes._
  import grvstage._

  object Annotated {
    def apply[V](value: V): Annotated[V] = Annotated(value, Seq.empty)
    def apply[V](value: V, note: Note): Annotated[V] = Annotated(value, Seq(note))
  }

  /**
   * Annotated is useful for collecting meta data during a multi-stage transformation. 
   * @param value The value at the current stage of the transformation. Monadic operations refer to this field only, not to notes.
   * @param notes The notes that have accumulated up through this stage of the transformation.
   * @tparam V The type of the value
   */
  case class Annotated[+V](value: V, notes: Seq[Note] = Seq.empty) {

    /**
     * @param note A new note to add to the seq of notes
     * @return This value with a new note added to the seq
     */
    def annotate(note: Note) = Annotated(value, notes :+ note)
    def annotate[N](canBeNote: N)(implicit noteMaker: CanBeNote[N]) = Annotated(value, notes :+ noteMaker.toNote(canBeNote))

    /**
     * Transform the value using the function f, adding no new notes during the process.
     * @param f The transformation function
     * @tparam T The type returned by f
     * @return An Annotated with the a new value of type T, with the same notes as given
     */
    def map[T](f: V => T) = {
      Annotated(f(value), notes)
    }

    /**
     * Transform the value using the function f, adding the notes from the Annotated instance generated during f.
     * @param f The transformation function
     * @tparam T The type returned by f
     * @return An Annotated with the a new value of type T, with any notes generated by f
     */
    def flatMap[T](f: V => Annotated[T]) = {
      val newAnnot = f(value)
      Annotated(newAnnot.value, notes ++ newAnnot.notes)
    }

    /**
     * Split the annotated into its value and notes components. Useful when refactoring because you can leave the structure of code
     * similar to how you found it
     * val (value, notes) = annotatedMethod(param).tuple
     * @return A tuple of the value and notes
     */
    def tuple = (value, notes)

    /**
     * Collect any notes matching the given partial function and transform them accordingly
     * @param pf
     * @tparam N
     * @return
     */
    def collect[N](pf: PartialFunction[Note, N]) = notes.collect(pf)
  }

  /**
   * Alias for Annotated[Validation[NonEmptyList[F], S]]
   */
  type AnnotatedValidationNel[F, S] = Annotated[Validation[NonEmptyList[F], S]]

  implicit def ToAnnotatedOps[S](s: S) = new AnnotatedOps[S]{
    def self = s
  }

  trait AnnotatedOps[S] {
    def self: S
    def annotate(note: Note) = Annotated(self, Seq(note))
    def annotate(notes: Seq[Note]) = Annotated(self, notes)

    def annotate[N](ns: Seq[N])(implicit noteMaker: CanBeNote[N]) = Annotated(self, ns.map(n => noteMaker.toNote(n)))
    def annotate[N](n: N)(implicit noteMaker: CanBeNote[N]) = Annotated(self, Seq(noteMaker.toNote(n)))

    def failNotes[F](implicit noteMaker: CanBeNote[S]) = {
      val validation = Validation.failure[NonEmptyList[S], F](NonEmptyList(self))
      val notesList = Seq(noteMaker.toNote(self))
      Annotated(validation, notesList)
    }

    def successNotes[F] = Annotated(Validation.success[NonEmptyList[F], S](self))
    def successNotes[F, N](note: N)(implicit noteMaker: CanBeNote[N]) = Annotated(Validation.success[NonEmptyList[F], S](self), Seq(noteMaker.toNote(note)))
    def successNotes[F, N](notes: Seq[Note]) = Annotated(Validation.success[NonEmptyList[F], S](self), notes)
  }

  trait CanBeNote[N]{
    def toNote(t: N): Note
  }

  object CanBeNote {
    implicit def stringCanBeNote = new CanBeNote[String] {
      override def toNote(msg: String): Note = MsgNote(msg)
    }

//    implicit def failureResultCanBeNote[N <: FailureResult] = new CanBeNote[N] {
//      override def toNote(n: N): Note = MsgNote(n.message)
//    }
  }

  //Maybe these two should live elsewhere?
  def toNote[N](n: N)(implicit noteMaker: CanBeNote[N], stage: Stage) = noteMaker.toNote(n)
  def toNotes[M[_], N](mt: M[N])(implicit noteMaker: CanBeNote[N], traverser: Traverse[M], stage: Stage) = traverser.map(mt)(noteMaker.toNote)
}


object NotEqual_TypeConstraintChecker {
  trait <:!<[A, B]

  implicit def nsub[A, B] : A <:!< B = new <:!<[A, B] {}
  implicit def TypeConstraintViolated[A, B >: A] : A <:!< B = sys.error("Unexpected call")
  implicit def TypesCannotBeEqual[A, B >: A] : A <:!< B = sys.error("Unexpected call")
}
